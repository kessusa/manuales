def process_match_flow_results(result, fw_and_node_info):
    min_flow_result = {}

    for item in (i for i in result if i['type'] == 'match-flow'):
        flow_parts = item['flow'].split()
        if len(flow_parts) != 3:
            continue

        source_ip, destination_ip, port = flow_parts
        source_ip = normalize_ip(source_ip)
        destination_ip = normalize_ip(destination_ip)
        current_fw_tag = item['tag']

        owner_fw_src = fw_and_node_info.get(source_ip, {}).get('firewall_misc', '')
        owner_fw_dst = fw_and_node_info.get(destination_ip, {}).get('firewall_misc', '')
        if current_fw_tag not in (owner_fw_src, owner_fw_dst):
            continue

        flow = (item['flow'], item['tag'])
        position = int(item['position'])

        if flow not in min_flow_result or position < int(min_flow_result[flow]['position']):
            min_flow_result[flow] = {
                **item,
                'source_ip': source_ip,
                'source_node_name': fw_and_node_info[source_ip]['node_normalization'],
                'destination_ip': destination_ip,
                'destination_node_name': fw_and_node_info[destination_ip]['node_normalization'],
                'port': port
            }

    return list(min_flow_result.values())


@login_required
@user_passes_test(user_can_change_firewall)
def ajax_load_data_check_flow_open(request):
    form_data = request.GET.copy()
    ticket_id = form_data.get('ticket_id')

    context = {}

    # Get data from Serenity API
    serenity_obj = SerenityAPI(env='prd')
    serenity_data = serenity_obj.get_data(ticket_id)
    context["result"] = sorted(serenity_data or [], key=lambda x: int(x['ar_number']))

    # Initialize PlayflowsAPI object
    obj_playflows = PlayflowsAPI()
    sid = obj_playflows.get_sid()

    # Process each AR separately
    for ar_data in context["result"]:
        sources = ar_data['sources']
        destinations = ar_data['destinations']
        services = ar_data['services']

        # Build fw_and_node_info, fw_policies, source_str and destination_str in one pass
        fw_and_node_info = {}
        fw_policies_set = set()
        source_ips = []
        destination_ips = []

        for source in sources:
            ip = normalize_ip(source['ip_address'])
            fw_and_node_info[ip] = {
                'node_normalization': source.get('node_normalization', ''),
                'firewall_misc': source.get('firewall_misc', '').strip()
            }
            fw_policies_set.add(fw_and_node_info[ip]['firewall_misc'])
            source_ips.append(source['ip_address'])

        for destination in destinations:
            ip = normalize_ip(destination['ip_address'])
            fw_and_node_info[ip] = {
                'node_normalization': destination.get('node_normalization', ''),
                'firewall_misc': destination.get('firewall_misc', '').strip()
            }
            fw_policies_set.add(fw_and_node_info[ip]['firewall_misc'])
            destination_ips.append(destination['ip_address'])

        fw_policies = list(fw_policies_set)
        source_str = ';'.join(source_ips)
        destination_str = ';'.join(destination_ips)
        service_str = ';'.join(services)

        # Match flow PRD
        result = obj_playflows.match_flow(
            sid=sid,
            tag=fw_policies,
            source=source_str,
            destination=destination_str,
            service=service_str
        )
        processed_results = process_match_flow_results(result, fw_and_node_info)

        # Generate "to_code" information for dropped flows
        to_code = {}
        for item in processed_results:
            if item['action'] == 'drop':
                fw_tag = item['tag']
                if fw_tag not in to_code:
                    to_code[fw_tag] = {
                        'sources': set(),
                        'destinations': set(),
                        'services': set(),
                    }
                to_code[fw_tag]['sources'].add(item['source_ip'])
                to_code[fw_tag]['destinations'].add(item['destination_ip'])
                to_code[fw_tag]['services'].add(item['port'])

        processed_to_code = {
            tag: {
                'sources': sorted(list(details['sources'])),
                'destinations': sorted(list(details['destinations'])),
                'services': sorted(list(details['services'])),
            }
            for tag, details in to_code.items()
        }

        ar_data['match_flow_results'] = processed_results
        ar_data['fw_and_node_info'] = fw_and_node_info
        ar_data['to_code'] = processed_to_code

        # CIS part if needed
        if _user_in_groups(request.user, ['emea_netsec']):
            tag_list = PlayflowsTag.objects.filter(
                region='cis',
                tag_name__in=fw_policies
            ).values_list('tag_name', flat=True)

            if not tag_list.exists():
                tag_list = list(fw_policies)
                obj_playflows_cis = PlayflowsAPI(env='cis')
                sid_cis = obj_playflows_cis.get_sid()

                cis_result = obj_playflows_cis.match_flow(
                    sid=sid_cis,
                    tag=tag_list,
                    source=source_str,
                    destination=destination_str,
                    service=service_str
                )
                cis_processed_results = process_match_flow_results(cis_result, fw_and_node_info)

                # Generate "to_code" for CIS dropped flows
                cis_to_code = {}
                for item in cis_processed_results:
                    if item['action'] == 'drop':
                        fw_tag = item['tag']
                        if fw_tag not in cis_to_code:
                            cis_to_code[fw_tag] = {
                                'sources': set(),
                                'destinations': set(),
                                'services': set(),
                            }
                        cis_to_code[fw_tag]['sources'].add(item['source_ip'])
                        cis_to_code[fw_tag]['destinations'].add(item['destination_ip'])
                        cis_to_code[fw_tag]['services'].add(item['port'])

                cis_processed_to_code = {
                    tag: {
                        'sources': sorted(list(details['sources'])),
                        'destinations': sorted(list(details['destinations'])),
                        'services': sorted(list(details['services'])),
                    }
                    for tag, details in cis_to_code.items()
                }

                ar_data['cis_match_flow_results'] = cis_processed_results
                ar_data['cis_to_code'] = cis_processed_to_code

    return JsonResponse(context)
